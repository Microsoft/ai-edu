<!--Copyright © Microsoft Corporation. All rights reserved.
  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可-->




# ONNX模型结构

在之前几节的内容中，我们没有借助任何框架的内容，而是用了python或者Julia去手写网络，去训练得到结果。现在假设我们已经保存了训练的结果，也就是说，我们保存了训练得到的计算图和对应的权重，那我们如何把训练得到的模型和主流框架中的模型结构统一起来呢？也就是说，让我们训练得到的结果可以直接放在主流框架里使用呢？

当然这个问题有暴力解法，反正是简单的网络结构，而且权重是已经知道的，那我就干脆就用各种框架从新把网络结构写一遍，然后把对应的权重参数读入，放到对应的层里面去，这不就大功告成了嘛！

这个解法不够那么优雅，作为一个还有头发的优雅程序员，我们要优雅的做这样一个转换：给定一个模型和目标对象，让程序来帮我们转换成目标的框架下对应的模型！换句话说，造一个能和主流框架接轨的轮子。

不会复用轮子的程序员不是好程序员！在这个方向有什么轮子是可以拿来用的呢？在这里我们选择ONNX作为复用的轮子。

## ONNX是什么？

关于这个问题，你已经是个成熟的轮子了，应该会自己介绍自己了，所以，请你来一段[自我介绍](https://github.com/onnx/onnx)可好？

简单来说，onnx模型可以帮助我们把我们自己的模型转换为任何一种主流深度学习框架可以识别的模型，也就是说，让我们训练得到的模型接入主流深度学习框架的轨道。

## 如何将模型保存为ONNX格式？

在ONNX的设定中，计算是依靠“结点”的结构来实现的，每个结点拥有自己的输入输出和操作类型，两个结点之间的连接是依靠寻找相同名字的输入输出来实现连接的，也就是说，相同名字的变量会被认为是同一个变量，如果一个结点的输出名字和另一个结点的输入名字相同，这两个结点会被认为是连接在一起的。如何生成一个ONNX的结点呢？这里我们要依靠ONNX的[python API](https://github.com/onnx/onnx/blob/9afc06c5f3b92344bdbedd488ab399d7763d17ce/onnx/helper.py#L20)，也就是下图这样一些代码，

```python
def make_node(
        op_type,  # type: Text
        inputs,  # type: Sequence[Text]
        outputs,  # type: Sequence[Text]
        name=None,  # type: Optional[Text]
        doc_string=None,  # type: Optional[Text]
        domain=None,  # type: Optional[Text]
        **kwargs  # type: Any
):  # type: (...) -> NodeProto
    """Construct a NodeProto.

    Arguments:
        op_type (string): The name of the operator to construct
        inputs (list of string): list of input names
        outputs (list of string): list of output names
        name (string, default None): optional unique identifier for NodeProto
        doc_string (string, default None): optional documentation string for NodeProto
        domain (string, default None): optional domain for NodeProto.
            If it's None, we will just use default domain (which is empty)
        **kwargs (dict): the attributes of the node.  The acceptable values
            are documented in :func:`make_attribute`.
    """
```

onnx目前支持的op_type类型可以在[这里](https://github.com/onnx/onnx/blob/master/docs/Operators.md)进行查找。

我们来尝试进行一次卷积层的转换，首先，我们进入到op_type中对应卷积的[部分](https://github.com/onnx/onnx/blob/master/docs/Operators.md#Conv)，
在这里，我们可以看到卷积层对应的参数有很多，比如group，dilations等等。我们先来考虑一个简单的情况，就是一个仅仅只设置了strides和pads的卷积层，应该如何进行转换。

先来看Conv部分下的example：

```python
x = np.array([[[[0., 1., 2., 3., 4.],  # (1, 1, 5, 5) input tensor
                [5., 6., 7., 8., 9.],
                [10., 11., 12., 13., 14.],
                [15., 16., 17., 18., 19.],
                [20., 21., 22., 23., 24.]]]]).astype(np.float32)
W = np.array([[[[1., 1., 1.],  # (1, 1, 3, 3) tensor for convolution weights
                [1., 1., 1.],
                [1., 1., 1.]]]]).astype(np.float32)

# Convolution with padding
node_with_padding = onnx.helper.make_node(
    'Conv',
    inputs=['x', 'W'],
    outputs=['y'],
    kernel_shape=[3, 3],
    # Default values for other attributes: strides=[1, 1], dilations=[1, 1], groups=1
    pads=[1, 1, 1, 1],
)
y_with_padding = np.array([[[[12., 21., 27., 33., 24.],  # (1, 1, 5, 5) output tensor
                             [33., 54., 63., 72., 51.],
                             [63., 99., 108., 117., 81.],
                             [93., 144., 153., 162., 111.],
                             [72., 111., 117., 123., 84.]]]]).astype(np.float32)
expect(node_with_padding, inputs=[x, W], outputs=[y_with_padding],
       name='test_basic_conv_with_padding')

# Convolution without padding
node_without_padding = onnx.helper.make_node(
    'Conv',
    inputs=['x', 'W'],
    outputs=['y'],
    kernel_shape=[3, 3],
    # Default values for other attributes: strides=[1, 1], dilations=[1, 1], groups=1
    pads=[0, 0, 0, 0],
)
y_without_padding = np.array([[[[54., 63., 72.],  # (1, 1, 3, 3) output tensor
                                [99., 108., 117.],
                                [144., 153., 162.]]]]).astype(np.float32)
expect(node_without_padding, inputs=[x, W], outputs=[y_without_padding],
       name='test_basic_conv_without_padding')
```

这是一个pad为1，步长为1，卷积核大小是3的卷积层，输入是数据(X)和对应的卷积核(W)，输出(Y)。需要注意的是，这里的x,w,y均是名称，对应的数据是通过名称输入到卷积层中进行操作的。

仿照这个例子，我们来自己写一个卷积层转换的函数。这个转换函数需要哪些参数呢？在现在我们只考虑有strides和pads的情况下，我们要接受的是卷积核的名称，输入数据的名称，输出数据的名称，步长和pads的大小这样一些参数，然后仿照这个例子进行一个书写。Talk is cheap, Show me the code!

```python

def make_conv(
    input_name,  # a string
    output_name, # a string
    weights,     # a numpy array stored the weights, [W, H, inputChannels, outputChannels]
    strides = [1, 1], # a list stored the strides, default [1, 1]
    pads=[1, 1, 1, 1],# a list stored the pads, default [1, 1, 1, 1]
    node_list=[],     # a list stored all the nodes, default [] 
):

    # transform the weights axes
    # since the weights in the onnx is stored in the format [outputChannels, inputChannels, H, W]
    # whether use the two swapaxes depends on your own implementation in the conv forward process
    weights = np.swapaxes(weights, 0, 3)
    weights = np.swapaxes(weights, 1, 2)

    # use a constant node to store the weights
    # since the weights is constant during the forward process
    node_list.append(
        helper.make_node(
            "Constant",
            inputs=[],
            outputs=[input_name + "weights"],
            value=helper.make_tensor(
                name=node[input_name + "weights"],
                data_type=TensorProto.FLOAT,
                dims=weights.shape,
                vals=weights.flatten().astype(float),
                    ),
                )
            )

    # now we have the input's, output's and weights' name; pads list, strides list
    # we can make the conv node
    kernel_shape=weights.shape[2:4]
    node_list.append(
                helper.make_node(
                    "Conv",
                    [input_name, input_name + "weights"],
                    [output_name],
                    kernel_shape=kernel_shape,
                    strides=strides,
                    pads=pads
                )
            )

    return node_list, output_name
```

通过这样一个代码，给定对应的参数，我们就拥有了一个存储着可以执行卷积操作的结点和他对应的参数，之后将这样一个结点的集合(node_list)转换成图(make_graph)和模型(make_model)，我们就得到了一个onnx格式的模型啦！

其他各种类型的转换代码希望大家能够自行实现，[这里](https://github.com/Microsoft/ai-edu/tree/master/B-%E6%95%99%E5%AD%A6%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/B6-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/%E5%BE%AE%E8%BD%AF-%E6%96%B9%E6%A1%881/11.1/model_train/0-1mnist/transfer.py)我们也提供了一套转换代码作为参考(Note!: 具体代码细节与大家实现卷积层全连接层时候的实现细节有关，请在参考基础上作出适当改动)
