Copyright © Microsoft Corporation. All rights reserved.
  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可

## 4.2 梯度下降法

有了上一节的最小二乘法做基准，我们这次用梯度下降法求解w和b，从而可以比较二者的结果。

### 4.2.1 数学原理

在下面的公式中，我们规定x是样本特征值，y是样本标签值，z是预测值，下标i表示其中一个样本。

- 预设函数（Hypothesis Function）为：

$$z_i = x_i \cdot w + b \tag{1}$$

- 损失函数（Loss Function）为：

$$J(w,b) = \frac{1}{2} (z_i-y_i)^2 \tag{2}$$

- 求w的梯度

我们用J的值作为误差衡量标准，通过求w对它的影响，也就是J对w的偏导数，来得到w的梯度。由于J是通过公式1和公式2间接地联系到w的，所以我们使用链式求导法则，通过单个样本来求导：

$$
\frac{\partial{J}}{\partial{w}} = \frac{\partial{J}}{\partial{z_i}}\frac{\partial{z_i}}{\partial{w}}=(z_i-y_i)x_i \tag{3}
$$

- 求b的梯度

$$
\frac{\partial{J}}{\partial{b}} = \frac{\partial{J}}{\partial{z_i}}\frac{\partial{z_i}}{\partial{b}}=z_i-y_i \tag{4}
$$

### 4.2.2 代码实现

```Python
if __name__ == '__main__':

    reader = SimpleDataReader()
    reader.ReadData()
    X,Y = reader.GetWholeTrainSamples()

    eta = 0.1
    w, b = 0.0, 0.0
    for i in range(reader.num_train):
        # get x and y value for one sample
        x = X[i]
        y = Y[i]
        # get z from x,y
        z = x * w + b
        # calculate gradient of w and b
        db = z - y
        dw = (z - y) * x
        # update w,b
        w = w - eta * dw
        b = b - eta * db

    print("w=", w)    
    print("b=", b)
```

大家可以看到，在代码中，我们完全按照公式推导实现了代码，所以，大名鼎鼎的梯度下降，其实就是把推导的结果转化为数学公式和代码，直接放在迭代过程里！另外，我们并没有直接计算损失函数值，而只是把它融入在公式推导中。

### 4.2.3 运行结果

```
w= [1.71629006]
b= [3.19684087]
```
读者可能会注意到，上面的结果和最小二乘法的结果（w1=2.056827, b1=2.965434）相差比较多，这个问题我们留在本章稍后的地方解决。


### 4.2.4 读取文件数据

**注意：从本章开始，所有的样本数据的格式都是：每一行是一个样本的所有特征，每一列是某个特征的所有样本。**

比如，如果有一个4个样本的数据集，每个样本有两个特征，其数据结构是这样的：
最终，样本数据的样子是：

|样本Id|特征1|特征2|标签|
|---|---|---|---|
|1|$x_{1,1}$|$x_{1,2}$|$y_1$|
|2|$x_{2,1}$|$x_{2,2}$|$y_2$|
|3|$x_{3,1}$|$x_{3,2}$|$y_3$|
|4|$x_{4,1}$|$x_{4,2}$|$y_4$|

对于标签数据Y，一般只有一个标签值，所以是个(m,1)的二维矩阵，与X对应的。

```Python
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path

x_data_name = "X04.dat"
y_data_name = "Y04.dat"

def ReadData():
    Xfile = Path(x_data_name)
    Yfile = Path(y_data_name)
    if Xfile.exists() & Yfile.exists():
        X = np.load(Xfile)
        Y = np.load(Yfile)
        # 注意这里和前面的例子不同
        return X.reshape(1,-1),Y.reshape(1,-1)
    else:
        return None,None
```
在上面的code里的reshape，实际上是把一个一维数组(m,)变成1行m列的二维数组(1,m)。这个例子中，X只有一个特征，所以只有一行。

### 代码位置

ch04, Level2