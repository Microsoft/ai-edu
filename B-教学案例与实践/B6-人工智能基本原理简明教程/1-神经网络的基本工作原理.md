看过很多博客、文章，东一榔头西一棒子的，总觉得没有一个系列的文章把问题从头到尾说清楚，找东西很困难。有的博客、文章的质量还不算很理想，似是而非，或者重点不明确，或者直接把别人的博客抄袭过来......种种不靠谱，让小白们学习起来很困难，增加了学习曲线的陡峭程度。当然也有很多博主非常非常负责任，文章质量很高，只是连续度不够，正看得过瘾的时候，没有后续章节了。

从本文开始，我们试图用一系列博客，讲解现代神经网络的基本知识，使大家能够从真正的“零”开始，对神经网络、深度学习有基本的了解，并能动手实践。这是本系列的第一篇，我们先从神经网络的基本工作原理开始讲解。

# 神经元细胞的数学计算模型

神经网络由基本的神经元组成，下图就是一个神经元的数学/计算模型，便于我们用程序来实现。

<img src=".\Images\1\NeuranCell.png" width="400">

## 输入

(x1,x2,x3) 是外界输入信号，一般是一个训练数据样本的多个属性，比如，我们要识别手写数字0~9，那么在手写图片样本中，x1可能代表了笔画是直的还是有弯曲，x2可能代表笔画所占面积的宽度，x3可能代表笔画上下两部分的复杂度。

(W1,W2,W3) 是每个输入信号的权重值，以上面的 (x1,x2,x3) 的例子来说，x1的权重可能是0.5，x2的权重可能是0.2，x3的权重可能是0.3。当然权重值相加之后可以不是1。

还有个b是干吗的？一般的书或者博客上会告诉你那是因为$y=wx+b$，b是偏移值，使得直线能够沿Y轴上下移动。这是用结果来解释原因，并非b存在的真实原因。从生物学上解释，在脑神经细胞中，一定是输入信号的电平/电流大于某个临界值时，神经元细胞才会处于兴奋状态，这个b实际就是那个临界值。亦即当：

$$w1*x1 + w2*x2 + w3*x3 >= t$$

时，该神经元细胞才会兴奋。我们把t挪到等式左侧来，变成$(-t)$，然后把它写成b，变成了：

$$w1*x1 + w2*x2 + w3*x3 + b >= 0$$

于是b诞生了！

## 求和计算

$$Z = w1*x1 + w2*x2 + w3*x3 + b = \sum_{i=1}^m(w_i*x_i) + b$$

在上面的例子中m=3。我们把$w_i*x_i$变成矩阵运算的话，就变成了：

$$Z = W*X + b$$

## 激活函数

求和之后，神经细胞已经处于兴奋状态了，已经决定要向下一个神经元传递信号了，但是要传递多强烈的信号，要由激活函数来确定：

$$A=\sigma{(Z)}$$

如果激活函数是一个阶跃信号的话，那受不了啊，你会觉得脑子里总是一跳一跳的，像继电器开合一样咔咔乱响，所以一般激活函数都是有一个渐变的过程，也就是说是个曲线。

<img src=".\Images\1\activation.png" width="400">

激活函数的更多描述在后续的博客中。

至此，一个神经元的工作过程就在电光火石般的一瞬间结束了。

# 神经网络的基本训练过程

## 单层神经网络模型

这是一个单层的神经网络，有m个输入 (这里m=3)，有n个输出 (这里n=2)。在单个神经元里，b是个值。但是在神经网络中，我们把b的值永远设置为1，而用b到每个神经元的权值来表示实际的偏移值，亦即(b1,b2)，这样便于矩阵运算。也有些作者把b写成x0，其实是同一个意思，只不过x0用于等于1。

- (x1,x2,x3)是一个样本数据的三个特征值
- (w11,w12,w13)是(x1,x2,x3)到n1的权重
- (w21,w22,w23)是(x1,x2,x3)到n2的权重
- b1是n1的偏移
- b2是n2的偏移

<img src=".\Images\1\OneLayerNN.png" width="500">

从这里大家可以意识到，同一个特征x1，对于n1、n2来说，权重是不相同的，因为n1、n2是两个神经元，它们完成不同的任务（特征识别）。这就如同老师讲同样的课，不同的学生有不同的理解。

而对于n1来说，x1，x2，x3输入的权重也是不相同的，因为它要对不同特征有选择地接纳。这就如同一个学生上三门课，但是侧重点不同，第一门课花50%的精力，第二门课30%，第三门课20%。

## 训练流程

从真正的“零”开始学习神经网络时，我没有看到过一个流程图来讲述训练过程，大神们写书或者博客时都忽略了这一点，我在这里给大家画一个简单的流程图：

<img src=".\Images\1\TrainFlow.png" width="640">

损失函数和反向传播的更多内容在后续的博客中。

## 前提条件

1. 首先是我们已经有了训练数据，否则连目标都没有，训练个啥？
2. 我们已经根据数据的规模、领域，建立了神经网络的基本结构，比如有几层，每一层有几个神经元
3. 定义好损失函数来合理地计算误差

## 步骤

假设我们有以下训练数据样本：

|Id|x1|x2|x3|Y|
|---|---|---|---|---|
|1|0.5|1.4|2.7|3|
|2|0.4|1.3|2.5|5|
|3|0.1|1.5|2.3|9|
|4|0.5|1.7|2.9|1|

其中，x1，x2，x3是每一个样本数据的三个特征值，Y是样本的真实结果值，

1. 随机初始化权重矩阵，可以根据高斯分布或者正态分布等来初始化。这一步可以叫做“蒙”，但不是瞎蒙。
2. 拿一个或一批数据作为输入，带入权重矩阵中计算，再通过激活函数传入下一层，最终得到预测值。在本例中，我们先用Id-1的数据输入到矩阵中，得到一个A值，假设A=5
3. 拿到Id-1样本的真实值Y=3
4. 计算损失，假设用均方差函数 $Loss = (A-Y)^2=(5-3)^2=4$
5. 根据一些神奇的数学公式（反向微分），把Loss=4这个值用大喇叭喊话，告诉在前面计算的步骤中，影响A=5这个值的每一个权重矩阵，然后对这些权重矩阵中的值做一个微小的修改（当然是向着好的方向修改，这一点可以用数学家的名誉来保证）
6. 用Id-2样本作为输入再次训练（goto 2）
7. 这样不断地迭代下去，直到以下一个或几个条件满足就停止训练：损失函数值非常小；迭代了指定的次数；计算机累吐血了......

训练完成后，我们会把这个神经网络中的结构和权重矩阵的值导出来，形成一个计算图（就是矩阵运算加上激活函数）模型，然后嵌入到任何可以识别/调用这个模型的应用程序中，根据输入的值进行运算，输出预测值。

# 神经网络中的矩阵运算

下面这个图就是一个两层的神经网络，包含隐藏层和输出层：

<img src=".\Images\1\TwoLayerNN.png" width="600">

其中，w1-m,n（应该写作$w^1_{1,1},w^1_{1,2},w^1_{1,3}$，上面的角标1表示第1层，但是visio里不支持这种格式）表示第一层神经网络的权重矩阵，w2-m,n（应该写作$w^2_{1,1},w^2_{1,2},w^2_{1,3}$）表示第二层神经网络的权重矩阵。

$$Z^1_1 = w^1_{1,1}x_1+w^1_{1,2}x_2+w^1_{1,784}x_{784}+b_1^1\\
......\\
Z^1_{10} = w^1_{10,1}x_1+w^1_{10,2}x_2+w^1_{10,784}x_{784}+b_{10}^{1}$$

变成矩阵运算：

$$
Z_1^1=\begin{pmatrix}w^1_{1,1}&w^1_{1,2}&...&w^1_{1,784}\end{pmatrix}
\begin{pmatrix}x_1\\x_2\\...\\x_{784}\end{pmatrix}
+b^1_1\\
.....\\
Z_{10}^1=
\begin{pmatrix}w^1_{10,1}&w^1_{10,2}&...&w^1_{10,784}\end{pmatrix}
\begin{pmatrix}x_1\\x_2\\...\\x_{784}\end{pmatrix}
+b^1_{10}
$$

再变成大矩阵：

$$Z_1 = 
\begin{pmatrix}
w^1_{1,1}&w^1_{1,2}&...&w^1_{1,784} \\
w^1_{2,1}&w^1_{2,2}&...&w^1_{2,784}\\
......\\
w^1_{10,1}&w^1_{10,2}&...&w^1_{10,784}
\end{pmatrix}
\begin{pmatrix}x_1\\x_2\\x_3\\...\\...\\x_{783}\\x_{784}\end{pmatrix} 
+\begin{pmatrix}b^1_1\\b^1_2\\...\\ b^1_{10}
\end{pmatrix}$$

最后变成矩阵符号：

$$Z_1 = W_1X + B_1$$

然后是激活函数运算：

$$A_1=\sigma{(Z_1)}$$

同理可得：

$$Z_2 = W_2A_1 + B_2$$
$$A_2=\sigma{(Z_2)}$$


# 神经网络为什么能普遍适用

单层的神经网络能够模拟一条二维平面上的直线，从而可以完成线性分割任务。而理论证明，两层神经网络可以无限逼近任意连续函数。

比如下面这张图，二维平面中有两类点，红色的和蓝色的，用一条直线肯定不能把两者分开了。

<img src=".\Images\1\Sample.png" width="600">

我们使用一个两层的神经网络可以得到一个非常近似的结果，使得分类误差在满意的范围之内。而这个真实的连续函数的原型是：

$$y=0.4x^2 + 0.3xsin(15x) + 0.01cos(50x)-0.3$$

哦，my god! 这么复杂的函数，一个两层的神经网络是如何做到的呢？其实从输入层到隐藏层的矩阵计算，就是对输入数据进行了空间变换，使其可以被线性可分，然后输出层画出了一个分界线。而训练的过程，就是确定那个空间变换矩阵的过程。因此，多层神经网络的本质就是对复杂函数的拟合。我们可以在后面的试验中来学习如何拟合上述的复杂函数的。

# 为什么需要激活函数

为什么我们不能在没有激活输入信号的情况下完成神经网络的学习呢？

如果我们不运用激活函数的话，则输出信号将仅仅是一个简单的线性函数。线性函数一个一级多项式。现如今，线性方程是很容易解决的，但是它们的复杂性有限，并且从数据中学习复杂函数映射的能力更小。一个没有激活函数的神经网络将只不过是一个线性回归模型（Linear regression Model）罢了，它功率有限，并且大多数情况下执行得并不好。我们希望我们的神经网络不仅仅可以学习和计算线性函数，而且还要比这复杂得多。同样是因为没有激活函数，我们的神经网络将无法学习和模拟其他复杂类型的数据，例如图像、视频、音频、语音等。这就是为什么我们要使用人工神经网络技术，诸如深度学习（Deep learning），来理解一些复杂的事情，一些相互之间具有很多隐藏层的非线性问题，而这也可以帮助我们了解复杂的数据。

那么为什么我们需要非线性函数？

非线性函数是那些一级以上的函数，而且当绘制非线性函数时它们具有曲率。现在我们需要一个可以学习和表示几乎任何东西的神经网络模型，以及可以将输入映射到输出的任意复杂函数。神经网络被认为是通用函数近似器（Universal Function Approximators）。这意味着他们可以计算和学习任何函数。几乎我们可以想到的任何过程都可以表示为神经网络中的函数计算。
而这一切都归结于这一点，我们需要应用激活函数f（x），以便使网络更加强大，增加它的能力，使它可以学习复杂的事物，复杂的表单数据，以及表示输入输出之间非线性的复杂的任意函数映射。因此，使用非线性激活函数，我们便能够从输入输出之间生成非线性映射。
激活函数的另一个重要特征是：它应该是可以区分的。我们需要这样做，以便在网络中向后推进以计算相对于权重的误差（丢失）梯度时执行反向优化策略，然后相应地使用梯度下降或任何其他优化技术优化权重以减少误差。

<img src=".\Images\1\Linearvsactivation.png" width="600">

# 为什么需要深度神经网络与深度学习

两层的神经网络虽然强大，但可能只能完成二维空间上的一些曲线拟合的事情。如果对于图片、语音、文字序列这些复杂的事情，就需要更复杂的网络来理解和处理。第一个方式是增加每一层中神经元的数量，但这是线性的，不够有效。另外一个方式是增加层的数量，每一层都处理不同的事情。

浅神经网络虽然具备了反向传播机制，但是仍存在问题：
1. 梯度越来越疏，从后向前，误差校正信号越来越微弱
2. 随机初始化会导致训练过程收敛到局部最小值
3. 需要数据带标签(人工label好的数据)，但是大部分数据没标签

## Deep Learning的训练过程简介

1. 使用自下上升非监督学习（就是从底层开始，一层一层的往顶层训练）：
   采用无标签数据（有标签数据也可）分层训练各层参数，这一步可以看作是一个无监督训练过程，是和传统神经网络区别最大的部分（这个过程可以看作是feature learning过程）。
   具体的，先用无标签数据训练第一层，训练时先学习第一层的参数（这一层可以看作是得到一个使得输出和输入差别最小的三层神经网络的隐层），由于模型capacity的限制以及稀疏性约束，使得得到的模型能够学习到数据本身的结构，从而得到比输入更具有表示能力的特征；在学习得到第n-1层后，将n-1层的输出作为第n层的输入，训练第n层，由此分别得到各层的参数；

2. 自顶向下的监督学习（就是通过带标签的数据去训练，误差自顶向下传输，对网络进行微调）：
   基于第一步得到的各层参数进一步fine-tune整个多层模型的参数，这一步是一个有监督训练过程；第一步类似神经网络的随机初始化初值过程，由于deep learning的第一步不是随机初始化，而是通过学习输入数据的结构得到的，因而这个初值更接近全局最优，从而能够取得更好的效果；所以deep learning效果好很大程度上归功于第一步的feature learning过程。
