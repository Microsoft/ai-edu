Copyright © Microsoft Corporation. All rights reserved.
  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可
  
# 知识点

- 线性分类
- Softmax使用
- 交叉熵代价函数

# 提出问题

由于北京的特殊地理位置，政治经济文化医疗教育.......的中心，人口密集，城市拥挤，空气污染问题一直被人们所关注。下面这组数据，是不同温度、湿度下的PM2.5（可入肺颗粒物）、PM10（可吸入颗粒物）、TSP（总悬浮颗粒物）在地表人类活动层的主要占比。

那么我们的问题是：当给你一个温度和湿度的组合值时，判断当前那种污染物占主要比重？

下图中，红点代表PM2.5，蓝点代表PM10，绿点代表TSP。

<img src=".\Images\6\data.png">

## 问题分析

从图示来看，似乎在三者之间有两个比较明显的分界线，我们如何通过神经网络精确地找到这两条分界线呢？

- 从视觉上判断是线性可分的，所以我们使用单层神经网络即可
- 输入特征是温度和湿度，所以我们在输入层设置两个输入X1, X2
- 最后输出的是三个分类，分别是PM2.5，PM10，TSP，所以输出层有三个神经元

# 定义神经网络结构

这个网络只有输入层和输出层，由于输入层不算在内，所以是一层网络。

<img src=".\Images\6\NN.jpg">

与前面的单层网络不同的是，本图最右侧还多出来一个Softmax分类函数（可以看作是激活函数），这是多分类任务中的标准配置。前面我们讲激活函数时提到过它，大家可以回去复习一下相关知识。

## 输入层

样本数据集中一共有200个数据，每个数据有两个特征，温度和湿度。所以定义矩阵如下：

$$
Xm = 
\begin{pmatrix}
x_1 \\ x_2
\end{pmatrix}
$$

$Xm$表示第m个样本值，写成Xm是为了不是一般性。

## 权重矩阵W1/B1

W权重矩阵的尺寸，可以从后往前看，比如：输出层是3个神经元，输入层是2个特征，则W的尺寸就是3x2。
B的尺寸是3x1，行数永远和W一样，列数永远是1。

## 输出层

输出层三个神经元，再加上一个Softmax计算，最后有A1,A2,A3三个输出，写作：

$$
A = \begin{pmatrix}A1\\A2\\A3\end{pmatrix}
$$

# 训练数据

样本数据集中一共有200个数据，每个数据有两个特征，温度和湿度。所以定义矩阵如下：

$$
X = 
\begin{pmatrix}
X1 & X2 \dots X200
\end{pmatrix}=
\begin{pmatrix}
x1_1 & x2_1 \dots x200_1 \\
x1_2 & x2_2 \dots x200_2 \\
 \end{pmatrix}
$$

$Xm$表示第m个样本值，$xm_n$表示第m个样本的第n个特征值。这里m=100，n=2。


样本标签数据：
$$
Y = 
\begin{pmatrix}
Y1 & Y2 \dots Ym
\end{pmatrix}=
\begin{pmatrix}
y1_1 & y2_1 \dots y200_1 \\
y1_2 & y2_2 \dots y200_2 \\
y1_3 & y2_3 \dots y200_3
\end{pmatrix}=
\begin{pmatrix}
1 & 0 \dots 0 \\
0 & 0 \dots 1 \\
0 & 1 \dots 0
\end{pmatrix}
$$

标签数据对应到每个样本数据上，列对齐，只有(1,0,0)，(0,1,0)，(0,0,1)三种组合，分别表示第一类(PM2.5)、第二类(PM10)和第三类(TSP)污染物所占主要比重。当然我们不能排除当期既有PM2.5又有PM10的情况，但两者总有一个占比重大，一个占比重小，所以就指定占比大的那个为1，其余两个为0。

# 前向计算

```Python
def Forward(W, X, B):
    Z = np.dot(W,X) + B
    return Z
```

# 分类函数

```Python
def Softmax(Z):
    shift_z = Z - np.max(Z)
    exp_z = np.exp(shift_z)
    V = exp_z / np.sum(exp_z)
    return V
```

# 反向传播
```Python
def BackPropagation(Xm, Ym, A):
    dloss_z = A - Ym
    db = dloss_z
    dw = np.dot(dloss_z, Xm.T)
    return dw, db
```

# 初始化

# 主循环

# 运行结果分析

